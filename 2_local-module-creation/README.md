# Создание локального модуля

### Описание создания модуля
В директории `mymodule-example`:
- `mymodule.h` и `mymodule.cpp` - непосредсвенно класс, выполняющий всю логику модуля. 
- `main.cpp` - файл, необходимый для присоединения модуля к системе робота. 
- `CMakeLists.txt` и `qiproject.xml ` - файлы, необходимые для компиляции с помощью `qibuild`.


Более детально: если скомпилировать наш модуль, то на выходе получим файл с расширением .so, который можно динамически прилинковать к системе робота. При этом нужно использовать toolchain для робота. 

### Описание программы для подключения к модулю
В директории `connect-to-module`:
- `main.cpp` - файл программы, которая подключается через прокси к нашему модулю и вызывает его функции. 
- `CMakeLists.txt` и `qiproject.xml ` - файлы, необходимые для компиляции с помощью `qibuild`.

С 10-ой по 60-ую строку в main.cpp происходит парсинг аргументов командной строки: при запуске программы можно отправить аргументом (с помощью ключа) IP-адрес робота, на котором мы хотим исполнить эту программу, и/или номер порта, однако ещё не понятно, за что это отвечает и на что влияет.

Далее мы создаём своего собственного брокера, чтобы с его помощью обращаться к другим модулям, в том числе и к предоставляемым фреймворком по умолчанию:

         boost::shared_ptr<AL::ALBroker> broker = AL::ALBroker::createBroker(brokerName, "0.0.0.0", 54000, pip, pport);
         
здесь `pip` и `pport` - наш IP-адресс и номер нашего порта, `0.0.0.0` и `54000` - какие-то магические числа, `brokerName` - строковая константа, имя брокера (опять-таки непонятно, за что это отвечает и на что влияет).

Далее мы вызываем конструктор собственных прокси, чтобы с помощью них вызывать функции модуля (здесь `MyModule` - название модуля, к которому мы хотим обращаться по этим прокси):

        AL::ALProxy proxy(broker, "MyModule");
        
и обращаемся с помощью них к функции `sayWord`, передав в качестве аргумента строковую константу `"Sentence to say!"` и указав тип возвращаемого значения `bool`:
   
        proxy.call<bool>("sayWord", "Sentence to say!");
   
Note: Если у вызываемой функции тип возвращаемого значения `void`, то нужно использовать `callVoid` вместо `call`.
   
### Как динамически прилинковать библиотеку

* Добавить файл с расширением .so, который создался в папке /build-.../sdk/lib/naoqi в результате сборки, в `/home/nao/some_directory` на роботе (о том, как это сделать, можно ещё раз прочитать [здесь](https://github.com/robocupmipt/tutorials/blob/master/1_installation/connection-to-the-robot.md)). 
* В файле `/home/nao/naoqi/preferences/autoload.ini` на роботе добавить строчку:

        -> [user]
    
        -> /path/to/libmymodule.so
