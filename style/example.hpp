#pragma once

// в основе - google style guide, см. https://google.github.io/styleguide/cppguide.html

// главное правило любого style guide-а - одни и те же вещи всегда нужно делать одинаково
// одинаковые отступы, одинаковый подход к именованию переменных, оформлению классов и т.п.

// "Пишите код так, как будто сопровождать его будет склонный к насилию психопат, который знает, где вы живёте"
// "Код в первую очередь пишется для людей, а не для машин"

// импорты упорядочивайте лексикографически
#include <atomic>
#include <conditional_variable>
#include <mutex>
//отделяйте импорты от классов пустой строкой

// именуйте классы с помощью CamelCase
class TicketLock {
 // сначала объявляйте публичные методы, именно они формируют интерфейс вашего класса
 // читателю в первую очередь важно знать, что умеет делать класс,
 // в последнюю - какие у этого класса поля, ведь он не имеет к ним доступа
 // отступ для private/protected/public - 1 пробел
 public:
  // стандартный отступ - 2 пробела,
  // для именования методов используйте CamelCase
  void Lock() {
    // для именования локальных переменных используйте snake_case
    // используйте const всегда, когда это возможно, в аргументах функций и при объявлении локальных переменных
    const std::size_t this_thread_ticket = next_free_ticket_.fetch_add(1);

    // разделяйте логические этапы в алгоритме пустыми строками
    // в данном случае мы разделяем doorway и wait секции
    while (this_thread_ticket != owner_ticket_.load()) { // после while и if ставьте пробел, ставьте пробел перед {
      std::this_thread::yield();
    }
  }

  // разделяйте методы пустыми строками, это облегчает навигацию по коду
  // и снова CamelCase для методов
  void Unlock() { // открывающая скобка на строке с именем функции, перед ней пробел
    // между операторами и операндами ставьте пробелы: a + b
    owner_ticket_.store(owner_ticket_.load() + 1);
  }

 // разделяйте пустыми строками секции в объявлении класса
 // поля класса объявляйте в отдельной private секции, менять состояние класса можно только через публичные методы
 private:
  // для имен полей используйте snake_case,
  // имена полей должны завершаться нижним подчеркиванием, так их можно отделить от локальных переменных при чтении
  // используйте осмысленные имена полей, по возможности не сокращая слова
  std::atomic<std::size_t> next_free_ticket_{0}; // инициализируем поля 
  // для хранения счетчиков используйте тип size_t
  std::atomic<std::size_t> owner_ticket_{0};
};

// классы разделяйте пустыми строками
class OnePassBarrier {
 public: // cначала - конструкторы и публичные методы
  explicit OnePassBarrier(const std::size_t num_threads) // аргументы - тоже const, если их не предполагается изменять
      : num_threads_{num_threads}, // для списка инициализации отступ - 4 пробела
        num_threads_arrived_{0} {  // поля выровнены
    // внутри стандартный отступ (в данном примере - 2 пробела)
  }

  // если класс не предполагается копировать или мувать, то явно запретите эти операции
  OnePassBarrier(const OnePassBarrier&) = delete;
  OnePassBarrier(OnePassBarrier&&) = delete;
  // ...

  // методы разделяйте пустыми строками
  void Pass() {
    // не захватывайте мьютексы руками, всегда используйте RAII-обертки, которые автоматически отпустят мьютекс при выходе из скоупа
    // для unique_lock используйте имя lock/locker, для lock_guard-а - guard
    // используйте lock_guard, когда мьютекс не планируется отпускать до завершения скоупа, unique_lock - в связке с условными переменными
    std::unique_lock<std::mutex> lock(mutex_);

    ++num_threads_arrived_;
    if (num_threads_arrived_ == num_threads_) {
      // даже один statement под if-ом оборачивайте в блок, явные границы упрощают чтение и позволяют избежать ошибок в будущем
      all_threads_arrived_cv_.notify_all(); 
    } else {
      while (num_threads_arrived_ < num_threads_) {
        all_threads_arrived_cv_.wait(lock);
      }
      // эквивалентная запись такого цикла ожидания: cv.wait(lock, predicate)
    }
  }

 // секции разделяйте пустыми строками
 private:
  // для числа каких-либо объектов используйте имена num_apples или apple_count
  // всегда указывайте, какие именно объекты вы считаете
  // используйте беззнаковый size_t, int почти никогда не нужен,
  // поскольку число потоков, токенов в семафоре, яблок и т.п. отрицательным не бывает
  std::size_t num_threads_;
  std::mutex mutex_;
  // имя условной переменной должно отражать предикат, которого на ней ждут и о котором сигналят
  std::condition_variable all_threads_arrived_cv_;
  // если поток читает/пишет в переменную только под мьютексом, то ее не нужно делать атомиком
  std::size_t num_threads_arrived_;
};
